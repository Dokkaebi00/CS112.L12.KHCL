1.Abstract: 
	- Given N tracks  
	- Found p,q parts that bring the most return on investment 

2.Pattern Recoginition: 
	- maximum subarray

3.Algorithm designed: 
	- dynamic programming
	- Input: n, arr 
	- Output: start_track_pos, end_track_pos, return_on_investment_result
	- Description: 
		if current sum is less than arr[i] -> ignore current sum
											-> sum = arr[i]
		sum, result = 0,0
		for i = 0 -> n: 
			sum = max(arr[i], sum + arr[i])
			result = max(result,sum) 
		return result

	- Time complexity: O(n) # Not sure about this





